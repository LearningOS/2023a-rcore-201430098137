# 实验1
- 增加按字节从内核空间复制数据到用户空间的方法,并用在了sys_task_info和sys_get_time两个系统调用上
- 将TaskControlBlock结构中的memory_set改成内部可变性结构，用于动态内存映射和解除映射
- 实现free_framed_area方法解除映射和复用insert_framed_area实现动态映射
- 捕获没法映射解除映射地址错误，从page_table一层层往上抛

## 问答作业
- 1.访问只能有特权模式能访问的寄存器或执行的指令时，会报非法指令错误，并杀掉用户任务，访问非法地址没有报错
- 2.qemu会在初始化时将rustsbi加载到0x80000000位置，内核程序加载到0x82000000，先执行rustsbi,然后rustsbi跳到0x82000000执行内核程序。
当然现实中的程序qemu加载这一步是由bios来做的，即加电后，bios程序先把硬盘的第一个块加载到内存中，执行，第一个块及后面的块就相当于rustsbi的作用，直到加载到内核


## 实验难点
- 对开启分页模式后，内核地址空间如何访问用户地址空间的方式不熟，内核如果修改用户空间的变量，如果变量在实际的物理页面是在不同两页中的, 
因为考虑到多个系统调用都会用到， 想写一个通用的从内核空间拷贝到用户空间的方法
- 对修改大量代码有所顾虑，但修改后，反而通畅
- 实验2要提交lab1的报告，之前lab1我提交到ch3分支，这点希望改掉，不要再提交以前的lab报告